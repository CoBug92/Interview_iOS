## Что такое `deadlock`?

[**Вернутся к списку вопросов**](https://github.com/CoBug92/Interview_iOS/blob/master/README.md)

`Deadlock` - это тупик. Один поток ждет освобождения второго, а второй ждет освобождения первого. Таким образом происходит зависание приложения.
Пример: в качестве делегата передаем себя как сильную ссылку. А в контроллере делегате пытаемся удалить делегат. В случае с потоками происходит зависание.

Обратная ситуация - [`livelock`](https://github.com/CoBug92/Interview_iOS/blob/master/Answers/Multithreading/Livelock.md)


Хороший пример deadlock привели на хабре

Допустим в системе существуют две задачи с низким (А) и высоким (Б) приоритетом, которые используют два ресурса — X и Y:


![alt text](https://habrastorage.org/files/9d8/3a9/844/9d83a98445554b0486486c287d07b16d.png)

В момент времени T1 задача (А) блокирует ресурс X. Затем в момент времени T2 задачу (А) вытесняет более приоритетная задача (Б), которая в момент времени T3 блокирует ресурс Y. Если задача (Б) попытается заблокировать ресурс X (T4) не освободив ресурс Y, то она будет переведена в состояние ожидания, а выполнение задачи (А) будет продолжено. Если в момент времени T5 задача (А) попытается заблокировать ресурс Y, не освободив X, возникнет состояние взаимной блокировки — ни одна из задач (А) и (Б) не сможет получить управление.


Как избежать?
Взаимная блокировка возможна только тогда, когда в системе используется зависимый (вложенный) многопоточный доступ к ресурсам. Взаимной блокировки можно избежать, если не использовать вложенность, или если ресурс использует протокол увеличения приоритета.
Если после получения данных из сети в фоновой очереди, попытаемся использовать для возвращения на main queue метод sync, то мы мы получим взаимную блокировку (deadock).


**НИКОГДА НЕ вызывайте** метод sync на main queue, потому что это приведет к взаимной блокировке (deadlock) вашего приложения!

### Статьи по теме
[Многопоточность](https://habrahabr.ru/post/320152/)